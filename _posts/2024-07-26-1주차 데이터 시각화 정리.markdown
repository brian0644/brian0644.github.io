---
layout: post
title:  "ML 1주차 정리"
date:   2024-07-26 17:13 +09:00
categories: ML
---
# **ML 1주차 정리**
## 1. EDA
  EDA: 가공하지 않은 원천의 데이터를 탐색하고 분석하는 것 (by 기술통계, 시각화)  
-> 극단적 해석, 지나친 추론, 자의적 해석은 되도록 지양한다.  
* 데이터의 형태와 척도가 분석에 알맞는지 확인 (sanity checking)  
* 데이터 평균, 분산, 분포, 패턴 확인 -> 특성파악  
* 결측값, 이상치 파악 및 보완  
* 변수간 관계성 확인  
* 분석 목적과 방향성 점검 및 보정  

### * EDA 실습
```python
##https://github.com/c-karl/DA_DS_Book001/blob/main/10.1.2.탐색적%20데이터%20분석(EDA).ipynb 참고
# [1] 필요한 패키지 임포트
import seaborn as sns 
import matplotlib.pylot as plt      # seabron과 matplotlib은 그래프 그리기용 패키지
import pandas as pd                 # Pandas는 데이터 분석과 데이터 조작을 위한 파이썬 라이브러리

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] 데이터 샘플 확인
df.head()                           # vs code에서는 print("여기 안에")

# [4] 각 칼럼의 속성 및 결측치 확인
df.info()                           # Non-Null count에서 결측치가 몇개인지 확인 가능, 자료형도 확인 가능

# [5] 각 칼럼의 통계치 확인
df.describe()                       # 기본적인 자료 개수, 평균, 중앙값 등의 통계치 산출

# [6] 각 칼럼의 왜도 확인
df.skew()

# [7] 각 칼럼의 첨도 확인
df.kurtosis()

# [8] 특정 변수 분포 시각화
sns.displot(df['lead_time'])        # 변수 1개 시각화

# [9] 호텔 구분에 따른 lead_time 분포 차이 시각화
sns.violinplot(x="hotel",y="lead_time", data=df, inner=None, color=".8")
sns.stripplot(x="hotel",y="lead_time", data=df, size=1)) # 변수 1개로 두개 그래프 생성.
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>

## 2. 공분산과 상관성 분석  

  공분산 : 서로 공유하는 분산값 but 두 변수간의 상관성 정도는 파악 불가  
  상관계수 : 공분산이 설명하지 못하는 상관성의 정도를 나타냄 (by 각자의 표준편차로 나눔)
  
<p style="text-align: center;">
<img width="236" alt="스크린샷 2024-07-26 오후 5 44 11" src="https://github.com/user-attachments/assets/61b7d8d8-1d4c-45fd-81ca-a60a08d7a355"><img width="189" alt="스크린샷 2024-07-26 오후 5 44 34" src="https://github.com/user-attachments/assets/f5092017-45d1-402f-a1bb-71d84419280e">
</p>

**중요한 것은 상관계수의 값과 직선의 기울기값과 관련없으며 두 변수의 선형관계만 측정할 수 있다**

### * 공분산과 상관성 분석 실습
```python
# [1] 전과 같게 + 필요한 패키지 임포트
import numpy as np                  # NumPy는 파이썬에서 과학 계산을 위한 핵심 라이브러리

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] 산점도 행렬 시각화
sns.set(font_scale=1.1)             # 폰트 크기 설정
sns.set_style('ticks')              # 축 눈금 설정
sns.pairplot(df,diag_kind='kde')    # 상관계수가 1이면 분포로 표시 >> 동일한 변수의 산점도를 분포로 표시, 왜냐면 어짜피 산점도는 직선으로 나오기 때문
plt.show()                          # 생성한 그래프 출력

# [4] 공분산 확인 (숫자형 자료에만)
df.cov()                            # 공분산은 두 데이터의 관계이기 때문에 행렬로 나타남. 마찬가지로 vscode에서는 print(안에)

# [5] 피어슨 상관계수 확인 (숫자형 자료에만)
df.corr(method='pearson')           # 기본 method는 피어슨, 그래서 피어슨 상관계수는 별도로 안적어줘도 됨

# [6] 히트맵 시각화
sns.heatmap(df.corr(), cmap='viridis') # (데이터, 색상) 설정하는 용도

# [7] clustermap 히트맵 시각화
sns.clustermap(df.corr(),annot = True, cmap= 'RdYlBu_r',vmin = -1, vmax = -1,)

# [8] 중복 제거 히트맵 시각화 (우상단 제거)
np.triu(np.ones_like(df.corr()))     # triu는 매트릭스의 우측 상단을 모두 True인 1로, 하단을 False인 0으로 변환. 좌하단 제거는 tril

mask = np.triu(np.ones_like(df.corr(), dtype=np.bool)) # True/False mask 배열로 변환

fig, ax = plt.subplots(figsize=(15,10))
sns.heatmap(df.corr(), mask=mask, vmin=-1, vmax=1, annot=True, cmap="RdYlBu_r", cbar=True)
ax.set_title('제목명', pad = 15)
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>

## 3. 시간 시각화

  시간 흐름에 따른 데이터의 변화를 표현하는 것
* 연속형 : 선그래프, 데이터 밀도가 높을 때 사용   ex) 초 단위의 공정 센서 데이터, 일년 간의 일별 판매량 데이터
* 막대형 : 막대그래프, 데이터 밀도가 낮을 때 사용  ex) 일년치 전체 데이터

**연속형의 경우 데이터의 양이 너무 많거나 변동이 심하면 패턴을 확인하는 것이 어려울 수 있다 => 추세선을 그려야한다**
-> 가장 일반적인 방법이 <u>이동평균방법 (데이터의 연속적 그룹의 평균을 구해서 추세선을 그리는 원리)</u>  


<p style="text-align: center;">
<img width="296" alt="스크린샷 2024-07-26 오후 11 41 10" src="https://github.com/user-attachments/assets/1deaa378-27b3-4f5c-b9e4-cea2ed65f07c">
</p>

**막대형의 경우 1년 동안의 월 간격 단위 흐름과 같이 시간의 밀도가 낮은경우 활용, 누적 막대그래프는 한 시점에 2개 이상의 세부 항목이 존재할때 사용한다.**

<p style="text-align: center;">
<img width="460" alt="스크린샷 2024-07-26 오후 11 41 15" src="https://github.com/user-attachments/assets/46eda5e7-a1ce-4c33-93e4-4f9a5d1e992e">
</p>


### * 시간 시각화 실습
```python
# [1] 필요한 패키지 임포트
import matplotlib.pyplot as plt
import pandas as pd
import datetime

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] date 칼럼 날짜 형식 변환
df['Date2']= pd.to_datetime(df['Order Date'], infer_datetime_format=True) # Order date 문자형을 날짜형으로 변환해서 Date2 새로운 열로 저장
df = df.sort_values(by='Date2')                                           # df데이터에 Date2라는 새로운 열을 오름차순으로 정렬
df['Year'] = df['Date2'].dt.year # 날짜형으로 변환된 Date2의 데이터에서 연도만 빼내기 위해서, .dt(datetime), .year(객체에서 연도 추출)로 Year 칼럼에 저장

# [4] 선그래프용 데이터셋 생성
df_line = df[df.Year == 2018]    # .Year을 통해 이전에 생성한 연도 칼럼 중 [df.Year == 2018]으로 2018년도 데이터만 선택한 새로운 데이터셋 df_line 정의
df_line = df_line.groupby('Date2')['Sales'].sum().reset_index() # .groupby('Date2')를 통해 Date2 값들 중 같은 값끼리 묶고 
                                                                # ['Sales'].sum()을 통해 Date2가 같은(같은 날) 값들 중 Sales의 합산 계산
                                                                # .reset_index()를 통해 0,1,2.. 기준으로 정렬(SQL의 auto incremental)

# [5] 30일 이동평균 생성
df_line['Month'] = df_line['Sales'].rolling(window=30).mean() # Month라는 새로운 열 생성,합계된 일별 판매량 데이터를 30일 씩 묶어서 이동평균계산 후 저장

# [6] 선그래프 시각화
ax = df_line.plot(x='Date2', y='Sales', linewidth = "0.5") # df_line의 데이터 중 X축은 Date2, Y축은 Sales로 선그래프 -> 일별 총 판매량 선 그래프
df_line.plot(x='Date2', y='Month', color='', linewidth ="", ax=ax) # 30일 이동평균 또한 그래프 생성 -> 추이선, ax=ax로 두그래프 겹치게 생성



# [7] 막대그래프용 데이터셋 생성
df_bar_1 = df.groupby('Year')['Sales'].sum().reset_index() # 연도별 판매량 데이터셋 생성

# [8] 연도별 매출액 막대그래프 시각화
ax = df_bar_1.plot.bar(x='Year', y='Sales', rot=0, figsize = (10,5))

# [9] 연도별, 고객별 매출액 데이터셋 생성
df_bar_2 = df.groupby(['Year','Segment'])['Sales'].sum().reset_index()

# [10] 고객별 칼럼으로 피벗
df_bar_2_pv = df_bar_2.pivot(index = 'Year', columns = 'Segment', values = 'Sales').reset_index() # Year은 2018행 2019행 이렇게 인덱스 역할
                                                                      # Segment 열의 고유한 값들(Customer, Corporate)은 피벗 테이블의 열로 사용
                                                                      # Sales의 값들이 value로 채워짐

# [11] 연도별 고객별 매출액 누적 막대 그래프 시각화
df_bar_2_pv.plot.bar(x = 'Year',stacked = True, figsize=() ) # stacked=True로 고객별 금액 누적 합산 출력, 애초에 값들이 Sales라 별도 y축 지정안함
                                                             # stacked=False로 두면 각 연도별로 세개의 막대 그래프 표현
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>
## 4. 비교 시각화

  그룹별 차이를 나타내기 위함
* 히트맵 : 그룹과 비교 요소가 많을 때 효과적, 각각의 셀은 색상이나 채도를 통해 데이터 값의 높고 낮음을 나타냄. 행은 그룹, 열은 요소
* 방사형 차트 : n각형 차트, 흔히 능력치 스탯 보여주는 도형 모양
* 평행 좌표 그래프 : 그룹별 요소 비교, 효과적으로 표현하려면 변수별 값을 정규화 하면 됨(가장 낮은 값은 0%, 가장 높은 값은 100%로 차이 부각)

  
<p style="text-align: center;">
<img width="373" alt="스크린샷 2024-07-27 오후 3 07 43" src="https://github.com/user-attachments/assets/c801f900-ca66-48e6-a7e8-cce3ab83e2b9">
<img width="458" alt="스크린샷 2024-07-27 오후 3 07 53" src="https://github.com/user-attachments/assets/c4b1fa4d-9f7f-4d44-a68b-dfbb0f734705">
<img width="402" alt="스크린샷 2024-07-27 오후 3 07 59" src="https://github.com/user-attachments/assets/fe204691-9b21-40b7-8f7e-f535c77a8131">
</p>

  
### * 비교 시각화 실습
```python
# [1] 필요한 패키지 임포트
import matplotlib.pyplot as plt
import pandas as pd
import datetime
import seaborn as sns
import numpy as np
from math import pi
from pndas.plotting import parallel_coordinates

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] 히트맵 시각화 V1을 위한 데이터 전처리
df1 = df[df['Tm'].isin(['ATL','BOS','BRK','CHI','CHO'])] # df 데이터에 있는 Tm(팀) 중 isin([''])으로 해당하는 5개의 팀만 df1에 저장
df1 = df1[['Tm','ORB%','TRB%','AST%','BLK%','USG%']]     # df1는 원래 선택된 5개 팀에 대한 모든 칼럼을 저장했지만 6개 칼럼으로 축소
df1 = df1.groupby('Tm').mean()                           # 팀별로 묶어서 정렬, Tm을 제외한 5개 칼럼의 평균값 계산 후 df1에 저장

# [4] 히트맵 시각화 V1
fig = plt.figure(figsize(8,8))  # 8x8 그림 생성
fig.set_facecolor('white')      # 그림 객체 배경 색칠
plt.pcolor(df1.values)          # df1 데이터프레임의 값을 사용하여 히트맵을 그림

plt.xticks(range(len(df1.columns)),df1.columns) # 위에서 생성한 그림 객체에 df1의 열 개수만큼 x축 틱(tick)을 생성, 그 틱의 위치에 df1의 열 이름을 대입
plt.yticks(range(len(df1.index)),df1.index)     # 위에서 생성한 그림 객체에 df1의 행 개수만큼 y축 틱(tick)을 생성, 그 틱의 위치에 df1의 행 이름을 대입
plt.xlabel('Value', fontsize = )                # x축의 이름 표시 
plt.ylabel('Team', fontsize = )                 # y축의 이름 표시
plt.colorbar()                                  # 우측 색상 설명 바 표시
plt.show()

# [5] 히트맵 시각화 V2를 위한 데이터 전처리
df2 = df[df['Tm'].isin(['ATL','BOS','BRK','CHI','CHO'])] # df 데이터에 있는 Tm(팀) 중 isin([''])으로 해당하는 5개의 팀만 df2에 저장
df2 = df2[['Tm','Age','G']]                              # df2는 원래 선택된 5개 팀에 대한 모든 칼럼을 저장했지만 3개 칼럼으로 축소
df2 = df2.groupby(['Tm','Age']).mean().reset_index()     # 팀별, 나이별로 묶어서 정렬, 남은 칼럼인 게임수 G에 대한 평균 계산 > 팀 속 나이별 평균게임 수
df2 = df2.pivot(index='Tm', columns='Age', values='G')   # 팀을 인덱스로, 칼럼은 나이, 평균 게임수가 데이터

# [6] 히트맵 시각화 V2
fig = plt.figure(figsize=(8,8)) # 8x8 그림 생성
fig.set_facecolor('white')      # 그림 객체 배경 색칠
plt.pcolor(df2.values)          # df2 데이터프레임의 값을 사용하여 히트맵을 그림

plt.xticks(range(len(df2.columns)), df2.columns) # 위에서 생성한 그림 객체에 df2의 열 개수만큼 x축 틱(tick)을 생성, 그 틱의 위치에 df2의 열 이름을 대입
plt.yticks(range(len(df2.index)), df2.index)     # 위에서 생성한 그림 객체에 df2의 행 개수만큼 y축 틱(tick)을 생성, 그 틱의 위치에 df2의 행 이름을 대입
plt.xlabel('Age', fontsize = )                   # x축의 이름 표시
plt.ylabel('Team', fontsize = )                  # y축의 이름 표시
plt.colorbar()                                   # 우측 색상 설명 바 표시
plt.show()

# [7] 방사형 차트 시각화
df3 = df1.reset_index()                          # df1 데이터 인덱스 초기화 후 df3에 저장
labels = df3.columns[1:]                         # df3의 칼럼을 0번 이후 1번부터 받아서 끝까지 Label로 저장
num_labels = len(labels)                         # 1~5까지니까 5 저장
angles = [x/float(num_labels)*(2*pi) for x in range(num_labels)] #x = 등분하고 싶은 점, num_label = n등분 > 즉 n등분한 등분점의 각도 계산
angles += angles[:1]                             # angles 리스트의 마지막에 첫 번째 요소가 추가 > 리스트에는 n+1개의 원소

mypalette = plt.cm.get_cmap("Set2", len(df3.index)) # mypalette는 Set2 컬러맵에서 df3 데이터프레임의 행 수에 맞는 색상 팔레트를 생성

fig = pit.figure(figsize=(15,20))                   # 15x20 그림 생성
fig.set_facecolor('white')                          # 그림 객체 배경 색칠

for i, row in df3.iterrows():
    color = my_palette(i)
    data = df3.iloc[i].drop('Tm').tolist()
    data += data[:1]

ax = plt.subplot(3,2,i+1, polar=True)
    ax.set_theta_offset(pi / 2) # 시작점 설정
    ax.set_theta_direction(-1)  # 시계방향 설정
    plt.xticks(angles[:-1], labels, fontsize=13)    # 각도 축 눈금 생성
    ax.tick_params(axis='x', which='major', pad=15) # 각 축과 눈금 사이 여백생
    ax.set_rlabel_position(0)                       # 반지름 축 눈금 라벨 각도 0으로 설정
    plt.yticks([0,5,10,15,20],['0','5','10','15','20'], fontsize=10)    # 반지름 축 눈금 설정
    plt.ylim(0,20)
    ax.plot(angles, data, color=color, linewidth=2, linestyle='solid')  # 방사형 차트 출력
    ax.fill(angles, data, color=color, alpha=0.4)                       # 도형 안쪽 색상 설정
    plt.title(row.Tm, size=20, color=color,x=-0.2, y=1.2, ha='left')    # 각 차트의 제목 생성
plt.tight_layout(pad=3) # 차트 간 간격 설정 
plt.show()

# [8] 평행 좌표 그래프 생성
fig,axes = plt.subplots()
plt.figure(figsize=(16,8)) # 그래프 크기 조정
parallel_coordinates(df3,'Tm',ax=axes, colormap='winter',linewidth = "0.5")
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>
