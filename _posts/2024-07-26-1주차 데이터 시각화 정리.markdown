---
layout: post
title:  "ML 1주차 정리"
date:   2024-07-26 17:13 +09:00
categories: ML
---
# **ML 1주차 정리**
## 1. EDA
  EDA: 가공하지 않은 원천의 데이터를 탐색하고 분석하는 것 (by 기술통계, 시각화)  
-> 극단적 해석, 지나친 추론, 자의적 해석은 되도록 지양한다.  
* 데이터의 형태와 척도가 분석에 알맞는지 확인 (sanity checking)  
* 데이터 평균, 분산, 분포, 패턴 확인 -> 특성파악  
* 결측값, 이상치 파악 및 보완  
* 변수간 관계성 확인  
* 분석 목적과 방향성 점검 및 보정  

### * EDA 실습
```python
# [1] 필요한 패키지 임포트
import seaborn as sns 
import matplotlib.pylot as plt      # seabron과 matplotlib은 그래프 그리기용 패키지
import pandas as pd                 # Pandas는 데이터 분석과 데이터 조작을 위한 파이썬 라이브러리

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] 데이터 샘플 확인
df.head()                           # vs code에서는 print("여기 안에")

# [4] 각 칼럼의 속성 및 결측치 확인
df.info()                           # Non-Null count에서 결측치가 몇개인지 확인 가능, 자료형도 확인 가능

# [5] 각 칼럼의 통계치 확인
df.describe()                       # 기본적인 자료 개수, 평균, 중앙값 등의 통계치 산출

# [6] 각 칼럼의 왜도 확인
df.skew()

# [7] 각 칼럼의 첨도 확인
df.kurtosis()

# [8] 특정 변수 분포 시각화
sns.displot(df['lead_time'])        # 변수 1개 시각화

# [9] 호텔 구분에 따른 lead_time 분포 차이 시각화
sns.violinplot(x="hotel",y="lead_time", data=df, inner=None, color=".8")
sns.stripplot(x="hotel",y="lead_time", data=df, size=1)) # 변수 1개로 두개 그래프 생성.
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>

## 2. 공분산과 상관성 분석  

  공분산 : 서로 공유하는 분산값 but 두 변수간의 상관성 정도는 파악 불가  
  상관계수 : 공분산이 설명하지 못하는 상관성의 정도를 나타냄 (by 각자의 표준편차로 나눔)
  
<p style="text-align: center;">
<img width="236" alt="스크린샷 2024-07-26 오후 5 44 11" src="https://github.com/user-attachments/assets/61b7d8d8-1d4c-45fd-81ca-a60a08d7a355"><img width="189" alt="스크린샷 2024-07-26 오후 5 44 34" src="https://github.com/user-attachments/assets/f5092017-45d1-402f-a1bb-71d84419280e">
</p>

**중요한 것은 상관계수의 값과 직선의 기울기값과 관련없으며 두 변수의 선형관계만 측정할 수 있다**

### * 공분산과 상관성 분석 실습
```python
# [1] 전과 같게 + 필요한 패키지 임포트
import numpy as np                  # NumPy는 파이썬에서 과학 계산을 위한 핵심 라이브러리

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] 산점도 행렬 시각화
sns.set(font_scale=1.1)             # 폰트 크기 설정
sns.set_style('ticks')              # 축 눈금 설정
sns.pairplot(df,diag_kind='kde')    # 상관계수가 1이면 분포로 표시 >> 동일한 변수의 산점도를 분포로 표시, 왜냐면 어짜피 산점도는 직선으로 나오기 때문
plt.show()                          # 생성한 그래프 출력

# [4] 공분산 확인 (숫자형 자료에만)
df.cov()                            # 공분산은 두 데이터의 관계이기 때문에 행렬로 나타남. 마찬가지로 vscode에서는 print(안에)

# [5] 피어슨 상관계수 확인 (숫자형 자료에만)
df.corr(method='pearson')           # 기본 method는 피어슨, 그래서 피어슨 상관계수는 별도로 안적어줘도 됨

# [6] 히트맵 시각화
sns.heatmap(df.corr(), cmap='viridis') # (데이터, 색상) 설정하는 용도

# [7] clustermap 히트맵 시각화
sns.clustermap(df.corr(),annot = True, cmap= 'RdYlBu_r',vmin = -1, vmax = -1,)

# [8] 중복 제거 히트맵 시각화 (우상단 제거)
np.triu(np.ones_like(df.corr()))     # triu는 매트릭스의 우측 상단을 모두 True인 1로, 하단을 False인 0으로 변환. 좌하단 제거는 tril

mask = np.triu(np.ones_like(df.corr(), dtype=np.bool)) # True/False mask 배열로 변환

fig, ax = plt.subplots(figsize=(15,10))
sns.heatmap(df.corr(), mask=mask, vmin=-1, vmax=1, annot=True, cmap="RdYlBu_r", cbar=True)
ax.set_title('제목명', pad = 15)
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>

## 3. 시간 시각화

  시간 흐름에 따른 데이터의 변화를 표현하는 것
* 연속형 : 선그래프, 데이터 밀도가 높을 때 사용   ex) 초 단위의 공정 센서 데이터, 일년 간의 일별 판매량 데이터
* 막대형 : 막대그래프, 데이터 밀도가 낮을 때 사용  ex) 일년치 전체 데이터

**연속형의 경우 데이터의 양이 너무 많거나 변동이 심하면 패턴을 확인하는 것이 어려울 수 있다 => 추세선을 그려야한다**
-> 가장 일반적인 방법이 <u>이동평균방법 (데이터의 연속적 그룹의 평균을 구해서 추세선을 그리는 원리)</u>  


<p style="text-align: center;">
<img width="296" alt="스크린샷 2024-07-26 오후 11 41 10" src="https://github.com/user-attachments/assets/1deaa378-27b3-4f5c-b9e4-cea2ed65f07c">
</p>

**막대형의 경우 1년 동안의 월 간격 단위 흐름과 같이 시간의 밀도가 낮은경우 활용, 누적 막대그래프는 한 시점에 2개 이상의 세부 항목이 존재할때 사용한다.**

<p style="text-align: center;">
<img width="460" alt="스크린샷 2024-07-26 오후 11 41 15" src="https://github.com/user-attachments/assets/46eda5e7-a1ce-4c33-93e4-4f9a5d1e992e">
</p>


### * 시간 시각화 실습
```python
# [1] 필요한 패키지 임포트
import matplotlib.pyplot as plt
import pandas as pd
import datetime

# [2] 데이터 불러오기
df = pd.read_csv("데이터 경로")

# [3] date 칼럼 날짜 형식 변환
df['Date2']= pd.to_datetime(df['Order Date'], infer_datetime_format=True) # Order date 문자형을 날짜형으로 변환해서 Date2 새로운 열로 저장
df = df.sort_values(by='Date2')                                           # df데이터에 Date2라는 새로운 열을 오름차순으로 정렬
df['Year'] = df['Date2'].dt.year # 날짜형으로 변환된 Date2의 데이터에서 연도만 빼내기 위해서, .dt(datetime), .year(객체에서 연도 추출)로 Year 칼럼에 저장

# [4] 선그래프용 데이터셋 생성
df_line = df[df.Year == 2018]    # .Year을 통해 이전에 생성한 연도 칼럼 중 [df.Year == 2018]으로 2018년도 데이터만 선택한 새로운 데이터셋 df_line 정의
df_line = df_line.groupby('Date2')['Sales'].sum().reset_index() # .groupby('Date2')를 통해 Date2 값들 중 같은 값끼리 묶고 
                                                                # ['Sales'].sum()을 통해 Date2가 같은(같은 날) 값들 중 Sales의 합산 계산
                                                                # .reset_index()를 통해 0,1,2.. 기준으로 정렬(SQL의 auto incremental)

# [5] 30일 이동평균 생성
df_line['Month'] = df_line['Sales'].rolling(window=30).mean() # Month라는 새로운 열 생성,합계된 일별 판매량 데이터를 30일 씩 묶어서 이동평균계산 후 저장

# [6] 선그래프 시각화
ax = df_line.plot(x='Date2', y='Sales', linewidth = "0.5") # df_line의 데이터 중 X축은 Date2, Y축은 Sales로 선그래프 -> 일별 총 판매량 선 그래프
df_line.plot(x='Date2', y='Month', color='', linewidth ="", ax=ax) # 30일 이동평균 또한 그래프 생성 -> 추이선, ax=ax로 두그래프 겹치게 생성



# [7] 막대그래프용 데이터셋 생성
df_bar_1 = df.groupby('Year')['Sales'].sum().reset_index() # 연도별 판매량 데이터셋 생성

# [8] 연도별 매출액 막대그래프 시각화
ax = df_bar_1.plot.bar(x='Year', y='Sales', rot=0, figsize = (10,5))

# [9] 연도별, 고객별 매출액 데이터셋 생성
df_bar_2 = df.groupby(['Year','Segment'])['Sales'].sum().reset_index()

# [10] 고객별 칼럼으로 피벗
df_bar_2_pv = df_bar_2.pivot(index = 'Year', columns = 'Segment', values = 'Sales').reset_index() # Year은 2018행 2019행 이렇게 인덱스 역할
                                                                      # Segment 열의 고유한 값들(Customer, Corporate)은 피벗 테이블의 열로 사용
                                                                      # Sales의 값들이 value로 채워짐

# [11] 연도별 고객별 매출액 누적 막대 그래프 시각화
df_bar_2_pv.plot.bar(x = 'Year',stacked = True, figsize=() ) # stacked=True로 고객별 금액 누적 합산 출력, 애초에 값들이 Sales라 별도 y축 지정안함
                                                             # stacked=False로 두면 각 연도별로 세개의 막대 그래프 표현
```
<br>
<br>
____________________________________________________________________________________________________________________________________
<br>
<br>
